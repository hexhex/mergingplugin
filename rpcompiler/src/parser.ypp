%{
	#include <Parser.h>
	#include <stdio.h>
	#include <stdarg.h>

	// functions and data structures from the scanner
	int yylex();						/* scanner */
	extern FILE *yyin;
	extern std::vector<std::string> symboltable;		/* symbol table */
	extern int sourceline;  				/* input line number */
	extern int scannererrors;				/* number of scanner errors */
	extern Parser *parserinst;				/* the scanner's internal pointer to the currently executed parser instance (necessary to iterate through the input files) */
	extern void creaetStringBuffer(const char* str);	/* Scanning a string rather than files */
	extern void releaseStringBuffer();

	// yacc generated functions
	int yyerror(const char* errormsg);

	// Pointer to the final parse tree (is set when "Program" token was reduced successfully) and number of errors occurred during parsing
	ParseTreeNode *globalparsetree;
	bool parsed = false;
	int syntaxerrors = 0;
	int syntaxwarnings = 0;
%}

%start Program

%token TSECTIONCS TSECTIONBB TSECTIONRP TSEMICOLON TORBRACKET TCRBRACKET TIMPLICATION TCOLON TOCBRACKET TCCBRACKET TIDENTIFIER TNUMBER TLOGICALSYM TCOMMA TSLASH

// Data field of tokens:
//	- terminal tokens store an integer value (which is used either directly as numeric value or as index into the scanners' symbol table) and source line and column number
//	- nonterminals store a parse tree node (with subnodes)
%union {
	TerminalToken terminaltoken;		/* terminaltoken */
	ParseTreeNode *node;			/* parse tree node */
};

// Identifiers (TIDENTIFIER) are passed from the scanner in form of indices into the symbol table. Numbers (TNUMBER) are passed directly. All terminal nodes store a reference to the sourcecode position for more helpful error messages.
// All other nodes store an instance of ParseTreeNode (which is constructed during parsing) to build a parse tree.
%type <terminaltoken> TNUMBER TIDENTIFIER TSECTIONCS TSECTIONBB TSECTIONRP TSEMICOLON TORBRACKET TCRBRACKET TIMPLICATION TCOLON TOCBRACKET TCCBRACKET TLOGICALSYM TCOMMA TSLASH
%type <node> Program Sections Section CommonSignatureSection BeliefBaseSection RevisionPlanSection KeyValuePairs KeyValuePair Sources Predicates Predicate

/*
	Grammer in compact EBNF-like notation (* means 0 to arbitrary many times):

		Program			=>	Section*;
		Section			=>	TSECTIONCS CommonSignatureSection |
						TSECTIONBB BeliefBaseSection |
						TSECTIONRP RevisionPlanSection;
		CommonSignatureSection	=>	Predicate*;
		BeliefBaseSection	=>	KeyValuePair*;
		RevisionPlanSection	=>	TOCBRACKET KeyValuePair* Source* TCCBRACKET |
						TOCBRACKET TIDENTIFIER TCCBRACKET;
		Predicate		=>	TIDENTIFIER TCOLON TIDENTIFIER TSLASH TNUMBER TSEMICOLON;
		KeyValuePair		=>	IDENTIFIER TCOLON TIDENTIFIER TSEMICOLON;
		Source			=>	RevisionPlanSection TSEMICOLON


	Grammer as it is implemented (* unfolded):

		Program			=>	Sections;
		Sections		=>	Section Sections |
						;
		Section			=>	TSECTIONCS CommonSignatureSection |
						TSECTIONBB BeliefBaseSection |
						TSECTIONRP RevisionPlanSection;
		CommonSignatureSection	=>	Predicates;
		BeliefBaseSection	=>	KeyValuePairs;
		RevisionPlanSection	=>	TOCBRACKET KeyValuePairs Sources TCCBRACKET |
						TOCBRACKET TIDENTIFIER TCCBRACKET;
		KeyValuePairs		=>	KeyValuePair KeyValuePairs |
						;
		Predicates		=>	Predicate Predicate |
						;
		Predicate		=>	TIDENTIFIER TCOLON TIDENTIFIER TSLASH TNUMBER TSEMICOLON;
		KeyValuePair		=>	IDENTIFIER TCOLON TIDENTIFIER TSEMICOLON;
		Sources			=>	RevisionPlanSection TSEMICOLON Sources |
						;
*/

%%

Program :			Sections
				{
					// Flatten sections subtree and use result as final result
					globalparsetree = $$ = $1->flatten(ParseTreeNode::sections);
					delete $1;
				}

Sections :			Section Sections
				{
					$$ = new ParseTreeNode(ParseTreeNode::sections, 2, $1, $2);
				}
	|
				{
					// No more sections
					$$ = NULL;
				}
	;

Section :			TSECTIONCS CommonSignatureSection
				{
					$$ = $2;
				}
	|			TSECTIONBB BeliefBaseSection
				{
					$$ = new ParseTreeNode(ParseTreeNode::section_beliefbase, 1, $2);
				}
	|			TSECTIONRP RevisionPlanSection
				{
					$$ = new ParseTreeNode(ParseTreeNode::section_revisionplan, 1, $2);
				}
	|
				// Error handling
				TSECTIONCS error
				{
					std::cerr << "Error in file " << parserinst->getInputFileName(parserinst->getCurrentInputFileIndex()) << ", line " << sourceline << ": Syntax error in common signature definition that started in line " << $1.linenr << std::endl;
					$$ = NULL;
					syntaxerrors++;
				}
	|
				// Error handling
				TSECTIONBB error
				{
					std::cerr << "Error in " << parserinst->getInputFileName(parserinst->getCurrentInputFileIndex()) << ", line " << sourceline << ": Syntax error in belief base definition that started in line " << $1.linenr << std::endl;
					$$ = NULL;
					syntaxerrors++;
				}
	|
				// Error handling
				TSECTIONRP error
				{
					std::cerr << "Error in " << parserinst->getInputFileName(parserinst->getCurrentInputFileIndex()) << ", line " << sourceline << ": Syntax error in revision plan definition that started in line " << $1.linenr << std::endl;
					$$ = NULL;
					syntaxerrors++;
				}
	;

CommonSignatureSection :	Predicates
				{
					// Flatten predicate definition subtree
					$$ = $1->flatten(ParseTreeNode::section_commonsignature);
					delete $1;
				}

	;

BeliefBaseSection :		KeyValuePairs
				{
					$$ = new ParseTreeNode(ParseTreeNode::beliefbase, 1, $1->flatten(ParseTreeNode::kvpairs));
					delete $1;
				}
	;

RevisionPlanSection :		TOCBRACKET
					KeyValuePairs
					Sources
				TCCBRACKET
				{
					// Flatten key value pair subtree and source subtree
					$$ = new ParseTreeNode(ParseTreeNode::revisionplansection, 2, $2->flatten(ParseTreeNode::kvpairs), $3->flatten(ParseTreeNode::revisionsources));
					delete $2;
					delete $3;
				}
	|
				TOCBRACKET
					TIDENTIFIER
				TCCBRACKET
				{
					$$ = new ParseTreeNode(ParseTreeNode::datasource, 1, new StringTreeNode(symboltable[$2.iValue]));
				}
	|
				// Error handling
				TOCBRACKET
					error
				TCCBRACKET
				{
					std::cerr << "Error in " << parserinst->getInputFileName(parserinst->getCurrentInputFileIndex()) << ", line " << sourceline << ": syntax error in revision plan section that started in line " << $1.linenr << std::endl;
					$$ = NULL;
					syntaxerrors++;
				}
	;

Predicates :			Predicate Predicates
				{
					$$ = new ParseTreeNode(ParseTreeNode::predicatelist, 2, $1, $2);
				}
	|
				{
					// No more predicate definitions
					$$ = NULL;
				}
	;

Predicate :			TIDENTIFIER TCOLON TIDENTIFIER TSLASH TNUMBER TSEMICOLON
				{
					$$ = new ParseTreeNode(ParseTreeNode::predicate, 3, new StringTreeNode(symboltable[$1.iValue]), new StringTreeNode(symboltable[$3.iValue]), new IntTreeNode($5.iValue));
				}
	|
				// Error handling
				error TSEMICOLON
				{
					std::cerr << "Error in " << parserinst->getInputFileName(parserinst->getCurrentInputFileIndex()) << ", line " << sourceline << ": predicate definition expected" << std::endl;
					$$ = NULL;
					syntaxerrors++;
				}
	;

KeyValuePairs :			KeyValuePair KeyValuePairs
				{
					$$ = new ParseTreeNode(ParseTreeNode::kvpairs, 2, $1, $2);
				}
	|
				{
					// No more key value pairs
					$$ = new ParseTreeNode(ParseTreeNode::kvpairs, 2, NULL, NULL);
				}
	;

KeyValuePair :			TIDENTIFIER TCOLON TIDENTIFIER TSEMICOLON
				{
					$$ = new ParseTreeNode(ParseTreeNode::kvpair, 2, new StringTreeNode(symboltable[$1.iValue]), new StringTreeNode(symboltable[$3.iValue]));
				}
	|
				error TSEMICOLON
				// Error handling
				{
					std::cerr << "Error in " << parserinst->getInputFileName(parserinst->getCurrentInputFileIndex()) << ", line " << sourceline << ": key-value pair expected" << std::endl;
					$$ = NULL;
					syntaxerrors++;
				}
	;
	
Sources :			RevisionPlanSection TSEMICOLON Sources
				{
					$$ = new ParseTreeNode(ParseTreeNode::revisionsources, 2, $1, $3);
				}
	|
				{
					// No more sources
					$$ = new ParseTreeNode(ParseTreeNode::revisionsources, 2, NULL, NULL);
				}
	;
%%

Parser::Parser(std::vector<std::string> inputfiles, FILE *stdinfile) : parsefiles(true), isparsed(false), stdin(stdinfile), inputFiles(inputfiles), inputFileCounter(-1), currentInputFile(NULL) {
}

Parser::Parser(std::string i) : parsefiles(false), inputstring(i) {
}

void Parser::parse(){
	// Parse; lex will call getNextInputFile when EOF is reached
	parserinst = this;

	if (parsefiles){
		// Go to first input file
		yyin = getNextInputFile();

		if (yyparse() == 0 && syntaxerrors == 0){
		}else{
			delete globalparsetree;
			globalparsetree = NULL;
		}

		isparsed = true;
	}else{
		// Create string buffer
		creaetStringBuffer(inputstring.c_str());

		if (yyparse() == 0 && syntaxerrors == 0){
		}else{
			delete globalparsetree;
			globalparsetree = NULL;
		}

		releaseStringBuffer();
		isparsed = true;
	}
}

FILE* Parser::getNextInputFile(){
	if (!parsefiles) return NULL;

	// Close current file
	if (currentInputFile != NULL) fclose(currentInputFile);

	// Go to next file
	inputFileCounter++;
	if (inputFileCounter < inputFiles.size()){
			if (inputFiles[inputFileCounter] != std::string("--")){
			currentInputFile = fopen(inputFiles[inputFileCounter].c_str(), "r");
			fseek(currentInputFile, SEEK_SET, 0);
			return currentInputFile;
		}else{
			currentInputFile = this->stdin;
			return currentInputFile;
		}
	}else{
		// No more files
		return NULL;
	}
}

int Parser::getCurrentInputFileIndex(){
	return inputFileCounter;
}

std::string Parser::getInputFileName(int index){
	return inputFiles[inputFileCounter];
}

/**
 * "Entry" method for other modules. The method tries to parse the contents of standard input.
 * \param standard input: A valid program is expected to be passed on standard input
 * \return ParseTreeNode* In case of successful parsing, a pointer to the root of the constructed parse tree. Otherwise NULL is returned. Note that is parsing was successful, the tree needs to be freed by calling the root's destructor.
 */
ParseTreeNode* Parser::getParseTree(){
	return globalparsetree;
}

bool Parser::succeeded(){
	return isparsed && globalparsetree != NULL;
}

bool Parser::parsed(){
	return isparsed;
}

int Parser::getErrorCount(){
	return syntaxerrors + scannererrors;
}

int Parser::getWarningCount(){
	return syntaxwarnings;
}

/**
 * Is called on parsing errors.
 */
int yyerror(const char* errormessage){
//	std::cout << "  Parser error: " << errormessage << " in line " << sourceline << std::endl;
//	errors_parser++;
}
